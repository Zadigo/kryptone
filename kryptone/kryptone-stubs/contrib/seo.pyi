from functools import cached_property
from typing import (Any, Callable, DefaultDict, Deque, Dict, Iterable, List,
                    Literal, Optional, Tuple, TypedDict, Union)

from nltk import FreqDist
from selenium.webdriver.remote.webelement import WebElement

from kryptone.utils.urls import URL

EMAIL_REGEX: str


def long_text_processor(tokens) -> bool: ...


class PageAudit(TypedDict, total=False):
    date: str
    title: Optional[str]
    description: Optional[str]
    url: str
    page_content_length: int
    is_https: bool
    has_title: bool
    has_h1: bool
    h1: Optional[str]


class TFIDFProcessor:
    def __init__(self, documents: list[str] = ...) -> None: ...

    def _calculate_tf(
        self,
        document: Union[str, Iterable[str]]
    ) -> Dict[str, float]: ...

    def _calculate_idf(self) -> Dict[str, float]: ...

    def add_documents(self, documents: Union[str, List[str]]) -> None: ...
    def compute_tfidf(self) -> List[Dict[str, float]]: ...
    def compute_tfidf_matrix(self) -> Any: ...

    def filter_tokens_by_tfidf(
        self, 
        document_idx: int, 
        top_n: Optional[int] = ..., 
        threshold: Optional[float] = ...
    ) -> List[str]: ...

    def get_top_terms(
        self, 
        document_idx: int,
        n: int = 10
    ) -> List[tuple[str, float]]: ...

    def preprocess_text_with_tfidf(
        self, 
        keep_top_n: Optional[int] = ..., 
        min_tfidf: Optional[float] = ...
    ) -> List[List[str]]: ...


class TextMixin:
    nltk_downloads: bool = ...
    text_processors: List[Callable[[list[str]], bool]] = ...

    def get_page_text(self) -> Optional[str]: ...
    def run_processors(self, tokens) -> list[str]: ...

    def fit_transform(
        self,
        text: str,
        language: str = Literal['english'],
        keep_emails: bool = Literal[False]
    ) -> str: ...

    def fit(self, raw_text: str, **kwargs) -> str: ...


class SEOMixin(TextMixin):
    word_frequency_by_page: dict[str, str] = ...
    text_by_page = DefaultDict[dict[str, str]]
    text_tokens_by_page = DefaultDict[list[str]]
    website_tokens = Deque[str]
    stemmed_tokens = Deque[str]
    page_audits = DefaultDict[dict[str, Any]]

    @property
    def grouped_text(self) -> str: ...
    @property
    def get_page_description(self) -> str: ...
    @property
    def get_page_title(self) -> str: ...
    @property
    def get_page_keywords(self) -> str: ...
    @cached_property
    def page_speed_script(self) -> str: ...

    @property
    def has_head_title(self) -> bool: ...
    @property
    def title_is_valid(self) -> bool: ...
    @property
    def description_is_valid(self) -> bool: ...
    @staticmethod
    def normalize_integers(items) -> dict: ...
    def create_word_cloud(self, frequency: dict[str, int]) -> None: ...

    def create_graph(
        self,
        current_url: URL,
        x_values: list[str],
        y_values: list[int]
    ) -> None: ...

    def calculate_word_frequency(
        self,
        tokens: list[str]
    ) -> tuple[FreqDist, list[str, int]]: ...

    def create_stemmed_words(self, tokens: list[str]) -> list[str]: ...
    def audit_structure(self, audit: dict) -> None: ...
    def audit_head(self, audit: dict) -> None: ...
    def audit_images(self, audit: dict) -> None: ...
    def audit_structured_data(self, audit: dict) -> None: ...
    def audit_page_speed(self, audit: dict) -> None: ...

    def audit_page_status_code(
        self, current_url: URL, audit: dict) -> None: ...

    def audit_page(
        self,
        current_url: URL,
        generate_graph: bool = ...
    ) -> PageAudit: ...


class EmailMixin(TextMixin):
    emails_container: set = ...

    @staticmethod
    def identify_email(value: str) -> Union[str, None]: ...
    
    @staticmethod
    def parse_url(element: WebElement) -> Union[str, None]: ...

    def parse_protected_email(self, email: Union[URL, str]) -> str: ...
    def emails(self, text: str, elements: List[WebElement] = ...) -> None: ...
    def find_emails_from_text(self, text: str) -> set[str]: ...

    def find_emails_from_links(
        self,
        elements: List[WebElement]
    ) -> set[str]: ...
